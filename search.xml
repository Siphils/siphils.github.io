<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[好久不见，各位]]></title>
    <url>%2F2017%2F08%2F23%2Flong-time-no-see%2F</url>
    <content type="text"><![CDATA[好久不见，各位最近事情确实有点多（不只是代码，还有游戏，hhhhh），博客已经一段时间没有更新过了。最近把笔记本的windows10重装了，然后装上了Fedora双系统。在家里的台式电脑重装系统的间隙写下了这篇文章。 最近的状态 下个月24号要考计算机二级（C++），所以最近又在重新翻看C++ primer plus这本书。最近总是有点三心二意的。 Javascript学的不安分（其实是因为二级考试临近，很久不看C++了也是忘了很多）。 重写了一遍导航页面。 沉迷Pixiv的排行榜上面的大触的作品，于是几乎从零开始学Python的语法和爬虫并花了三天左右的时间写出一个一身是bug的爬虫，之后在排行榜上爬了差不多十个G的图片（天天舔屏幕）。除了下载在本地，还把爬虫放在自己的服务器上面保存每日top50的数据在json文件里，并且找了个瀑布流的源码用ajax加载json每天12点自动更新。Pixiv Top 50 daily。 看到别人的一些网站的服务器状态监控页面，于是自己在uptimerobot注册了个帐号并且把自己的页面都添加了进去。我的服务器状态监控页面。 注册了几个新的域名并且提交备案（差不多都备案好了）。 开始在着手自己另一个typecho博客的主题的代码编写（从零开始学php不算是吧hhh，因为初三时自学过一点），自己辣鸡的php和css和js水平还是给自己带来了不少的麻烦（一边写一边搜各种文档，效率很低），并且沉迷于pjax无缝刷新技术（我表示这个是比较大的坑），一知半解的水平还是有比较大的局限性的——一方面效率是比较低，另一方面很多都做不出自己想要的效果并且各种坑还特别难填上。 总体来说，还是先把c++复习好准备好考试，据说二级是比较简单但那么久没看了还是比较虚的…… 接下来的任务（无论轻松还是复杂，都要认真对待每一项任务） 复习好c++，二级考个好成绩 完善爬P站图片的Python爬虫 学习javascript 完成自己的第一个typecho主题，尽量做到让其支持pjax技术]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Page + hexo 搭建的新博客]]></title>
    <url>%2F2017%2F08%2F23%2FGithub-Page-hexo-new-blog%2F</url>
    <content type="text"><![CDATA[纠结了好久，最终还是决定从wordpress转移到这里，使用github page+hexo搭建博客（轻便啊！）暂时还是用着https://siphils.github.io 这个域名等我写好导航页之后再把域名绑定过来吧还有好多东西没怎么修改 懒…今天就弄这么多 等有时间了再慢慢逐渐修改吧（用修改一词不过只是在原主题的基础上做点小变动罢了）]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给博客更换了字体]]></title>
    <url>%2F2017%2F07%2F25%2Fuse-new-font%2F</url>
    <content type="text"><![CDATA[新字体：浪漫雅圆又是闲着没事干，随便弄了点东西。这个字体是我在逛一个博客时候看到的。打开next主题的_config.yml文件，找到如下字段12345678910111213141516171819202122232425262728293031323334353637font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default) host: # Global font settings used on &lt;body&gt; element. global: # external: true will load this font family from host. external: true family: Lato # Font settings for Headlines (h1, h2, h3, h4, h5, h6) # Fallback to `global` font settings. headings: external: true family: # Font settings for posts # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo # Fallback to `global` font settings. # The `size` option use `px` as unit logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 将font:设置为enable: true，再将host后面输入字体库的地址（省略http:）。然后在global一栏里将family设置为浪漫雅圆就可以将全站字体设置为这个啦~]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 学习笔记（二）]]></title>
    <url>%2F2017%2F07%2F23%2FJavascript-notes-2%2F</url>
    <content type="text"><![CDATA[我的FreeCodeCamp编码集Javascript参考文档一位Javascript初学者的一些笔记。FreeCodeCamp上初级的题目到这就结束了，其实做完很久了，现在才开始整理。 一首令人放松的BGM Truncate a string 截断字符串 （用瑞兹来截断对面的退路） 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。 但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 11) 应该返回 &quot;A-tisket...&quot;. truncate(&quot;Peter Piper picked a peck of pickled peppers&quot;, 14) 应该返回 &quot;Peter Piper...&quot;. truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, &quot;A-tisket a-tasket A green and yellow basket&quot;.length) 应该返回 &quot;A-tisket a-tasket A green and yellow basket&quot;. truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, &quot;A-tisket a-tasket A green and yellow basket&quot;.length + 2) 应该返回 &quot;A-tisket a-tasket A green and yellow basket&quot;. truncate(&quot;A-&quot;, 1) 应该返回 &quot;A...&quot;. truncate(&quot;Absolutely Longer&quot;, 2) 应该返回 &quot;Ab...&quot;. 其中提示用到String.slice()，这个方法完整语法是str.slice(beginSlice[, endSlice])，其中beginSlice是从这个索引开始提取原字符串的字符，endSlice是结束处的索引（提取的字符包括beginSlice而不包括endSlice）。那么直接根据num和str.length的长度判断即可，比较简单直接贴我自己的代码。123456789function truncate(str, num) &#123; if (num &lt; str.length) &#123; if (num &lt;= 3) str = str.slice(0, num) + "..."; else str = str.slice(0, num - 3) + "..."; &#125; return str;&#125; Chunky Monkey 猴子吃香蕉, 分割数组 （猴子吃香蕉可是掰成好几段来吃哦） 把一个数组arr按照指定的数组大小size分割成若干个数组块。 例如: chunk([1,2,3,4],2)=[[1,2],[3,4]]; chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]; chunk([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 2) 应该返回 [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]. chunk([0, 1, 2, 3, 4, 5], 3) 应该返回 [[0, 1, 2], [3, 4, 5]]. chunk([0, 1, 2, 3, 4, 5], 2) 应该返回 [[0, 1], [2, 3], [4, 5]]. chunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]]. chunk([0, 1, 2, 3, 4, 5, 6], 3) 应该返回 [[0, 1, 2], [3, 4, 5], [6]]. chunk([0, 1, 2, 3, 4, 5, 6, 7, 8], 4) 应该返回 [[0, 1, 2, 3], [4, 5, 6, 7], [8]]. 提示有Array.slice() slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改。 其中如果end大于长度的时候会提取到数组的末尾，那么这就比较简单了。写一个循环，计数器小于数组长度的时候每次加上size，然后用Arrary.slice(begin,end)（也是包括begin不包括end）把原数组分割之后push到一个新的数组里。123456function chunk(arr, size) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i += size) newArr.push(arr.slice(i, i + size)); return newArr;&#125; 我参考了一下一位大佬的解法，也是和我的代码一样（一本满足）。 Slasher Flick 截断数组 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。 slasher([1, 2, 3], 2) 应该返回 [3]. slasher([1, 2, 3], 0) 应该返回 [1, 2, 3]. slasher([1, 2, 3], 9) 应该返回 []. slasher([1, 2, 3], 4) 应该返回 []. slasher([&quot;burgers&quot;, &quot;fries&quot;, &quot;shake&quot;], 1) 应该返回 [&quot;fries&quot;, &quot;shake&quot;]. slasher([1, 2, &quot;chicken&quot;, 3, &quot;potatoes&quot;, &quot;cheese&quot;, 4], 5) 应该返回 [&quot;cheese&quot;, 4]. 从给出的例子判断应该是要返回剩下的数组，那么先判断howmany的值如果它等于0那么直接return arr，否则的话使用Array.splice()的方法，以howmany为start，arr.length - howmany为deleteCount对arr进行分割。需要注意的是，slice()和splice()方法不同，前者不会改变原数组的内容，而后者会改变原来数组的内容123456function slasher(arr, howMany) &#123; if (howMany === 0) return arr; else return arr.splice(howMany, arr.length - howMany);&#125; 参考一位dalao的解法12345const slasher = (arr, howMany) =&gt; arr.slice(howMany);// function slasher(arr, howMany) &#123;// // it doesn't always pay to be first// return arr.slice(howMany); // &#125; =&gt;是ES6的新特性，我打算先把比较基础的知识牢固再去考虑。 Mutations 比较字符串 （蛤蟆可以吃队友，也可以吃对手） 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。 举例 [&quot;hello&quot;, &quot;Hello&quot;]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。 [&quot;hello&quot;, &quot;hey&quot;]应该返回false，因为字符串&quot;hello&quot;并不包含字符&quot;y&quot;。 [&quot;Alien&quot;, &quot;line&quot;]应该返回true，因为&quot;line&quot;中所有字符都可以在&quot;Alien&quot;找到。 mutation([&quot;hello&quot;, &quot;hey&quot;])应该返回 false. mutation([&quot;hello&quot;, &quot;Hello&quot;]) 应该返回 true. mutation([&quot;zyxwvutsrqponmlkjihgfedcba&quot;, &quot;qrstu&quot;]) 应该返回 true. mutation([&quot;Mary&quot;, &quot;Army&quot;]) 应该返回 true. mutation([&quot;Mary&quot;, &quot;Aarmy&quot;]) 应该返回 true. mutation([&quot;Alien&quot;, &quot;line&quot;]) 应该返回 true. mutation([&quot;floor&quot;, &quot;for&quot;]) 应该返回 true. mutation([&quot;hello&quot;, &quot;neo&quot;]) 应该返回 false. 需要用到的是String.indexOf()，完整语法是str.indexOf(searchValue[, fromIndex])，其中searchValue表示是被查找的值，fromIndex是从该字符串中开始查找的索引位置，如果fromIndex &gt;= str.length或者找不到对应的searchValue那么这个方法都会返回-1。我的想法是用一个循环，遍历传入的数组的第二个元素，把第二个字符串元素的每一个字母当成一个新的元素，也就是看成一个二维数组，用indexOf()在第一个字符串中寻找有没有这个值，有就返回false。123456function mutation(arr) &#123; for (var i = 0; i &lt; arr[1].length; i++) if (arr[0].toLowerCase().indexOf(arr[1][i].toLowerCase()) == -1) return false; return true;&#125; 参考的dalao的解法12345678910111213141516171819function mutation(arr) &#123; return arr[1].toLowerCase().split('').every(v =&gt; arr[0].toLowerCase().includes(v)); /*return arr[1].toLowerCase().split('') .filter(v =&gt; arr[0].toLowerCase().indexOf(v)&lt;0) .length === 0;*/ /* return arr[1].toLowerCase().split("").map(v =&gt; arr[0].toLowerCase().indexOf(v)).indexOf(-1) == -1; or compare = arr[1].toLowerCase(); for (var i = 0; i &lt; compare.length; i++) &#123; if (arr[0].toLowerCase().indexOf(compare[i]) == -1)&#123; return false; &#125; &#125; return true;*/&#125; 也就是说我的解法与他给出的第三种解法是相同的，他的第一种解法用到了arr.every和=&gt;，其中前者测试这个数组是否满足所给的条件并且不会改变原数组的值。第二种解法用到了filter()。 Falsy Bouncer 过滤数组假值 （真假美猴王） 删除数组中的所有假值。 在JavaScript中，假值有false、null、0、&quot;&quot;、undefined 和 NaN。 bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9]) 应该返回 [7, &quot;ate&quot;, 9] bouncer([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) 应该返回 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]. bouncer([false, null, 0, NaN, undefined, &quot;&quot;]) 应该返回 []. bouncer([1, null, NaN, 2, undefined]) 应该返回 [1, 2]. 给到的提示有Array.filter() 这个方法一开始我是不太理解该怎么用，现在好一些了。 filter() 方法创建一个新数组,其包含通过所提供函数实现的测试的所有元素。 语法var new_array = arr.filter(callback[, thisArg])参数callback用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。thisArg可选。执行 callback 时的用于 this 的值。1234567891011121314151617function isBigEnough(value) &#123; return value &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44]// ES6 wayconst isBigEnough = value =&gt; value &gt;= 10;let [...spraed]= [12, 5, 8, 130, 44];let filtered = spraed.filter(isBigEnough);// filtered is [12, 130, 44] 提示有Boolean Objects和Array.filter()。一开始我没好好看提示，而且用了isNaN()，于是写出了下面错误的代码123456//wrong!function bouncer(arr) &#123; return arr.filter(function() &#123; return (val !== false &amp;&amp; val !== null &amp;&amp; val !== 0 &amp;&amp; val != "" &amp;&amp; val != undefined &amp;&amp; (!isNaN(val))); &#125;);&#125; 而且一开始我死活搞不懂错在哪，因为类似&quot;a&quot;这样的非空字符串也被筛选掉了。直到有人提示我isNaN（is Not a Number）是判断数字类型的，非空字符串也会返回true，所以无法达到题目的要求。后来知道要用上Boolean()判断一个变量是不是truthy,是falsy就返回false。于是代码修改如下12345function bouncer(arr) &#123; return arr.filter(function(val) &#123; return Boolean(val); &#125;);&#125; 运用ES6最新的=&gt;可以更加简洁123function bouncer(arr) &#123; return arr.filter(val =&gt; val);&#125; 参照一位dalao的解法123function bouncer(arr) &#123; return arr.filter(v =&gt; v);&#125; 与我的第三种解法一样。(PS:在这道题上花得时间比较长，因为没有直接用搜索引擎搜解法而是搜各种相关的方法自己想办法解决，头还是有点铁…) Seek and Destroy 摧毁数组 金克斯的迫击炮！ 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 destroyer([1, 2, 3, 1, 2, 3], 2, 3) 应该返回 [1, 1]. destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3) 应该返回 [1, 5, 1]. destroyer([3, 5, 1, 2, 2], 2, 3, 5) 应该返回 [1]. destroyer([2, 3, 2, 3], 2, 3) 应该返回 []. destroyer([&quot;tree&quot;, &quot;hamburger&quot;, 53], &quot;tree&quot;, 53) 应该返回 [&quot;hamburger&quot;]. 提示是Arguments Objects和Array.filter()。思路简单来说就是把除了第一个参数以外的参数放进一个数组里，再用Array.filter()和Array.indexOf()去筛选出不在参数列表里的元素，就可以达到题目的要求了。12345678910function destroyer(arr) &#123; var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; var newarr = arr.filter(function(val) &#123; return args.indexOf(val) &lt; 0; &#125;); return newarr;&#125; 参考dalao的做法1234const destroyer = (arr, ...args) =&gt; arr.filter(n =&gt; args.includes(n));// function destroyer(arr) &#123;// return arr.filter(n =&gt; ![...arguments].includes(n));// &#125; 好吧…我决定先mark了再慢慢看。 Where do I belong 数组排序并找出元素索引 我身在何处？ 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。 where([10, 20, 30, 40, 50], 35) 应该返回 3. where([10, 20, 30, 40, 50], 30) 应该返回 2. where([40, 60], 50) 应该返回 1. where([3, 10, 5], 3) 应该返回 0. where([5, 3, 20, 3], 5) 应该返回 2. where([2, 20, 10], 19) 应该返回 2. where([2, 5, 10], 15) 应该返回 3. 由题意知道首先要将数组排序，那么可以运用Array.sort()把数组由小到大（由大到小也可以，不过后半部分代码的逻辑需要修改）进行排序。123arr.sort(function(a,b)&#123; return a - b;&#125;); 然后用Array.indexOf()寻找给定的参数num中有没有对应，有的话就给出这个索引，没有就寻找大小关系。完整代码如下。123456789101112131415function where(arr, num) &#123; var indexNum; arr.sort(function(a, b) &#123; return a - b; &#125;); if (arr.indexOf(num) != -1) indexNum = arr.indexOf(num); else &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (num &gt; arr[i]) indexNum = i + 1; &#125; &#125; return indexNum;&#125; 参考dalao的代码123function getIndexToIns(arr, num) &#123; return arr.filter((a) =&gt; a &lt; num).length;&#125; 简单来说就是用filter筛选掉出比num小的数字，然后返回新数组的长度就是索引值。简洁易懂。 Caesars Cipher 凯撒密码 （让上帝的归上帝，凯撒的归凯撒） 下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。 移位密码也就是密码中的字母会按照指定的数量来做移位。 一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, &gt;’B’ ↔ ‘O’，以此类推。 写一个ROT13函数，实现输入加密字符串，输出解密字符串。 所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。 rot13(&quot;SERR PBQR PNZC&quot;) 应该解码为 &quot;FREE CODE CAMP&quot; rot13(&quot;SERR CVMMN!&quot;) 应该解码为 &quot;FREE PIZZA!&quot; rot13(&quot;SERR YBIR?&quot;) 应该解码为 &quot;FREE LOVE?&quot; rot13(&quot;GUR DHVPX OEBJA QBT WHZCRQ BIRE GUR YNML SBK.&quot;) 应该解码为 &quot;THE QUICK BROWN DOG JUMPED OVER THE LAZY FOX.&quot; 用到的方法有String.charCodeAt()和String.fromCharCode()。前者的参数是一个索引index，返回值是一表示给定索引处字符的 UTF-16 代码单元值的数字；如果索引超出范围，则返回 NaN；后者的参数是一组数字，表示的是Unicode的值，且返回的是一个字符串而不是string对象。那么我的思路就是用一个循环去寻找属于&#39;A&#39;和&#39;Z&#39;之间的字符，然后获得它们的UTF-16的代码单元值的数字去加13，如果大于77的就减13，最后用fromCharCode去得到原来的字符串。1234567891011121314151617function rot13(str) &#123; // LBH QVQ VG! var arr = []; var newStr = ""; for (var i = 0; i &lt; str.length; i++) &#123; if (str.charCodeAt(i) &lt; 65 || str.charCodeAt(i) &gt; 90) &#123; arr.push(str.charCodeAt(i)); continue; &#125; else if (str.charCodeAt(i) &gt; 77) &#123; arr.push(str.charCodeAt(i) - 13); &#125; else arr.push(str.charCodeAt(i) + 13); &#125; for (var j = 0; j &lt; arr.length; j++) &#123; newStr += String.fromCharCode(arr[j]); &#125; return newStr;&#125; 以下是参考一位dalao的解法123456789101112131415161718192021222324252627282930const rot13 = (str) =&gt; str.replace(/[A-Z]/g, l =&gt; String.fromCharCode(l.charCodeAt()%26 + 65));// return str.split('').map(l =&gt; &#123;// let i = l.charCodeAt(0);// return (i &lt; 65 || i &gt; 90) ? l : String.fromCharCode(i%26+65);// &#125;).join('');/*function rot13(str) &#123; // LBH QVQ VG! var charCodeArray = []; for (var i=0; i &lt; str.length; i++) &#123; var code = str.charCodeAt(i); if (code &gt; 90 || code &lt; 65) &#123; charCodeArray.push(code); &#125; else if (code&gt;=78) &#123; charCodeArray.push(code - 13); &#125; else &#123; charCodeArray.push(code + 13); &#125; &#125; var translatedStr =""; for (var j=0; j&lt;charCodeArray.length; j++)&#123; translatedStr += String.fromCharCode(charCodeArray[j]); &#125; return translatedStr;&#125;*/ 其中/* */包括的那部分代码与我的比较类似-W-。 这次整理代码整理到了深夜，复习了一遍学过的很多方法，也掌握了一些刚刚开始不太理解的方法和一些Object，收获颇丰啊。同时觉得自己的视野还是太窄了，还是要多多放在整合以前学过的东西上面，尽量用上学过的知识和不一样的思路去解决问题。 Rome was not built in a day.]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>FreeCodeCamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 学习笔记（一）]]></title>
    <url>%2F2017%2F07%2F16%2FJavascript-notes-1%2F</url>
    <content type="text"><![CDATA[我的FreeCodeCamp编码集Javascript参考文档一位Javascript初学者的一些笔记，慢慢积累吧。体会到了懂得使用方法和不懂使用方法的巨大差别……下面是一些算法自己的实现以及与一些dalao的比较 Reverse a String 先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。 你的结果必须得是一个字符串 reverseString(&quot;hello&quot;) 应该返回一个字符串 reverseString(&quot;hello&quot;) 应该返回 &quot;olleh&quot; reverseString(&quot;Howdy&quot;) 应该返回 &quot;ydwoH&quot; reverseString(&quot;Greetings from Earth&quot;) 应该返回 &quot;htraE morf sgniteerG&quot; 部分提示:12345//String.split() //Example var str = "hello world"; var arr = str.split(" "); console.log(arr); // ["hello","wordl"] 12345//Array.reverse() //Example var arr = [1,2,3]; arr.reverse(); console.log(arr); // [3,2,1] 12345//Array.join() //Example var arr = ["hello","world"]; var newArr = arr.join(" "); console.log(newArr); // hello world 我的想法：先用String.split(&quot; &quot;)将一句话根据空格分割开得到一个新的数组，然后将获得的数组使用方法Array.reverse()获得倒转后的数组。将这个数组每一个元素（String）视作一个Array，然后二重循环，第二重循环从末尾开始直至首元素依次存入一个新的数组，然后再使用方法Array.join(&quot; &quot;)得到倒转后的String123456789101112131415function reverseString(str) &#123; var strArr = str.split(" "); strArr.reverse(); var newStr = ""; var newArr = []; for (var i = 0; i &lt; strArr.length; i++) &#123; for (var j = strArr[i].length - 1; j &gt; -1; j--) &#123; newStr += strArr[i][j]; &#125; newArr.push(newStr); newStr = ""; &#125; str = newArr.join(" "); return str;&#125; 然后是@forkerino（帮我解决过问题。。）的实现123function reverseString(str) &#123; return str.split("").reverse().join("");&#125; 从中理解的思路是直接用String.split(&quot;&quot;)将整个字符串分成一个个字母（包括空格在内）的一个数组，然后用Array.reverse()方法倒转，再用Array.join(&quot;&quot;)重新组成一个字符串。 Factorialize a Number 计算一个整数的阶乘 如果用字母n来代表一个整数，阶乘代表着所有小于或等于n的整数的乘积。 阶乘通常简写成 n! 例如: 5! = 1 2 3 4 5 = 120 factorialize(5) 应该返回一个数字 factorialize(5) 应该返回 120. factorialize(10) 应该返回 3628800. factorialize(20) 应该返回 2432902008176640000. factorialize(0) 应该返回 1. 我的想法：解决阶乘比较经典的解法之一大概是递归吧12345function factorialize(num) &#123; if (num &gt; 1) return num * factorialize(num - 1); else return 1;&#125; @forkerino dalao的解法123function factorialize(num) &#123; return num &gt; 1 ? num * factorialize(num - 1) : 1;&#125; ? : 一个运算符简化了if...else的写法 Check for Palindromes 检查回文字符串 如果给定的字符串是回文，返回true，反之，返回false。 如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 注意你需要去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。 函数参数的值可以为”racecar”，”RaceCar”和”race CAR”。 palindrome(&quot;eye&quot;) 应该返回一个布尔值 palindrome(&quot;eye&quot;) 应该返回 true. palindrome(&quot;race car&quot;) 应该返回 true. palindrome(&quot;not a palindrome&quot;) 应该返回 false. palindrome(&quot;A man, a plan, a canal. Panama&quot;) 应该返回 true. palindrome(&quot;never odd or even&quot;) 应该返回 true. palindrome(&quot;nope&quot;) 应该返回 false. palindrome(&quot;almostomla&quot;) 应该返回 false. palindrome(&quot;My age is 0, 0 si ega ym.&quot;) 应该返回 true. palindrome(&quot;1 eye for of 1 eye.&quot;) 应该返回 false. palindrome(&quot;0_0 (: /-\ :) 0-0&quot;) 应该返回 true. 这个用到了正则表达式，由于我不太会正则表达式，就参考了下@forkerino dalao的解法1234function palindrome(str) &#123; var cleanStr = str.replace(/\W|_/g, "").toLowerCase() return cleanStr === cleanStr.split("").reverse().join("");&#125; 其中的 clean.split(&quot;&quot;).reverse().join(&quot;&quot;) 是之前Reverse a String 中他用到的解法。 Find the Longest Word in a String 找出最长单词 在句子中找出最长的单词，并返回它的长度。 函数的返回值应该是一个数字。 findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;) 应该返回一个数字 findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;) 应该返回 6. findLongestWord(&quot;May the force be with you&quot;) 应该返回 5. findLongestWord(&quot;Google do a barrel roll&quot;) 应该返回 6. findLongestWord(&quot;What is the average airspeed velocity of an unladen swallow&quot;) 应该返回 8. findLongestWord(&quot;What if we try a super-long word such as otorhinolaryngology&quot;) 应该返回 19. 思路比较简单，直接上代码12345678function findLongestWord(str) &#123; str = str.split(" "); var strLenth = str[0].length; for (var i = 0; i &lt; str.length; i++) &#123; if (strLenth &lt; str[i].length) strLenth = str[i].length; &#125; return strLenth;&#125; @forkerino 的解法暂时看不懂，在聊天室里有人提示我可以使用 Math.max()，于是查阅了一下参考手册。1234567891011//Math.max() //Example Math.(1,2,3); //3 //为了得到数值数组，可以使用如下两种方法 //1.getMaxOfArray([1,2,3])等价于Math.max(1,2,3) function getMaxOfArray(numArray) &#123; return Math.max.apply(null, numArray);&#125;; //2.使用最新的扩展语句spread operator var arr = [1, 2, 3]; var max = Math.max(...arr); 重新整理了一下思路，修改为以下代码12345678function findLongestWord(str) &#123; var strArr = str.split(" "); var lenArr = []; for (var i = 0; i &lt; strArr.length; i++) lenArr.push(strArr[i].length); //return Math.max(...lenArr); return Math.max.apply(null, lenArr);&#125; Title Case a Sentence 句中单词首字母大写 确保字符串的每个单词首字母都大写，其余部分小写。 像’the’和’of’这样的连接符同理。 titleCase(&quot;I&#39;m a little tea pot&quot;) 应该返回一个字符串 titleCase(&quot;I&#39;m a little tea pot&quot;) 应该返回 &quot;I&#39;m A Little Tea Pot&quot;. titleCase(&quot;sHoRt AnD sToUt&quot;) 应该返回 &quot;Short And Stout&quot;. titleCase(&quot;HERE IS MY HANDLE HERE IS MY SPOUT&quot;) 应该返回 &quot;Here Is My Handle Here Is My Spout&quot;. 我的想法：先用 String.toLowerCase() 将字符串中所有字母换为小写， String.split() 然后将字符串分开为一个个字符串组成的数组，再利用 String.substr() 获得每个字符串的首字母作为一个字符串12345678910//String.substr() //Example var str = "abcdefghij"; console.log("(1,2): " + str.substr(1,2)); // (1,2): bc console.log("(-3,2): " + str.substr(-3,2)); // (-3,2): hi console.log("(-3): " + str.substr(-3)); // (-3): hij console.log("(1): " + str.substr(1)); // (1): bcdefghij console.log("(-20, 2): " + str.substr(-20,2)); // (-20, 2): ab console.log("(20, 2): " + str.substr(20,2)); // (20, 2): 再用 String.toUpperCase() 换成大写字母。1234567function titleCase(str) &#123; var strArr = str.toLowerCase().split(" "); for (var i = 0; i &lt; strArr.length; i++) strArr[i] = strArr[i].substr(0, 1).toUpperCase() + strArr[i].substr(1); str = strArr.join(" "); return str;&#125; @forkerino dalao的方法123function titleCase(str) &#123; return str.split(' ').map(v =&gt; v[0].toUpperCase() + v.slice(1).toLowerCase()).join(' ');&#125; 其中使用了 Array.prototype.map() 方法，先mark以后再看。 Return Largest Numbers in Arrays 找出多个数组中的最大数 右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。 提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。 largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回一个数组 largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回 [27,5,39,1001]. largestOfFour([[4, 9, 1, 3], [13, 35, 18, 26], [32, 35, 97, 39], [1000000, 1001, 857, 1]]) 应该返回 [9, 35, 97, 1000000]. 我的思路：使用二重循环，内层循环里直接挨个找最大值，外层循环用Array.push() 放进一个新的数组里1234567891011function largestOfFour(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; var maxNum = arr[i][0]; for (var j = 0; j &lt; arr[i].length; j++) &#123; if (maxNum &lt; arr[i][j]) maxNum = arr[i][j]; &#125; newArr.push(maxNum); &#125; return newArr;&#125; 然后聊天室里有人提醒我可以用Math.max()，于是将代码修改如下1234567function largestOfFour(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) newArr.push(Math.max.apply(null, arr[i])); //newArr.push(Math.max(arr[i) return newArr;&#125; @forkerinodalao的代码1234567891011121314151617const largestOfFour = (a) =&gt; a.map(b =&gt; Math.max(...b));/*function largestOfFour(arr) &#123; return arr.map(sa =&gt; Math.max(...sa));&#125;*//*function largestOfFour(arr) &#123; // You can do this! for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].sort(function(a, b) &#123; return b - a; &#125;); arr[i] = arr[i][0]; &#125; return arr;&#125;*/ 看到Array.sort()，吓得我赶紧回头复习了一下相关的知识。 Confirm the Ending 检查字符串结尾 判断一个字符串 (str) 是否以指定的字符串 (target) 结尾。 如果是，返回true;如果不是，返回false。 confirmEnding(&quot;Bastian&quot;, &quot;n&quot;) 应该返回 true. confirmEnding(&quot;Connor&quot;, &quot;n&quot;) 应该返回 false. confirmEnding(&quot;Walking on water and developing software from a specification are easy if both are frozen&quot;, &quot;specification&quot;) 应该返回 false. confirmEnding(&quot;He has to give me a new name&quot;, &quot;name&quot;) 应该返回 true. confirmEnding(&quot;He has to give me a new name&quot;, &quot;me&quot;) 应该返回 true. confirmEnding(&quot;He has to give me a new name&quot;, &quot;na&quot;) 应该返回 false. confirmEnding(&quot;If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing&quot;, &quot;mountain&quot;) 应该返回 false. 我的想法：使用String.substr() 方法获取从String末尾开始的指定长度的字符串与target进行比对。123function confirmEnding(str, target) &#123; return (str.substr(-target.length) == target);&#125; @forkerino dalao的方法12345function confirmEnding(str, target) &#123; // "Never give up and good luck will find you." // -- Falcor return str.slice(-target.length) == target;&#125; 其中String.slice()和我使用的String.substr()是有所区别的（还有String.substring()，具体参考文档吧~~）。 Repeat a string repeat a string 重复输出字符串 （重要的事情说3遍） 重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。 repeat(&quot;\*&quot;, 3) 应该返回 &quot;\*\*\*&quot; . repeat(&quot;abc&quot;, 3) 应该返回 &quot;abcabcabc&quot;. repeat(&quot;abc&quot;, 4) 应该返回 &quot;abcabcabcabc&quot;. repeat(&quot;abc&quot;, 1) 应该返回 &quot;abc&quot;. repeat(&quot;\*&quot;, 8) 应该返回 &quot;\*\*\*\*\*\*\*\*&quot;. repeat(&quot;abc&quot;, -2) 应该返回 &quot;&quot;. 我的想法：构造一个新的字符串，用循环按次数将旧的字符串连接到新的字符串中，再返回新的字符串。123456function repeat(str, num) &#123; var newStr = ""; for (var i = 1; i &lt;= num; i++) newStr += str; return newStr;&#125; @forkerino dalao的代码123456789function repeatStringNumTimes(str, num) &#123; // repeat after me return num &gt; 0 ? str.repeat(num) : ""; // var res = ""; // for (var i = 0; i&lt;num; i++)&#123; // res += str; // &#125; // return res;&#125; 嗯…这次知道了String.repeat()这个方法…（不得不说熟悉方法之后，好多问题都简单得不行） 整理和码字大概用了一两个小时吧，一边整理一边复习其实也有不小的收获。 Rome was not built in a day.]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>FreeCodeCamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客底部添加了一言]]></title>
    <url>%2F2017%2F07%2F15%2FAdd-Hitokoto-at-bottom%2F</url>
    <content type="text"><![CDATA[最近没什么事情做就随便加了点东西 一言- ヒトコト 简单来说，一言（ヒトコト）指的是就是一句话，可以是动漫中的台词，可以是小说中的语句，也可以是网络上的各种小段子。或是感动，或是开心，又或是单纯的回忆，来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。 Hitokoto API1.将下面这段代码放入HTML页面的head标签内1&lt;script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&amp;charset=utf-8"&gt;&lt;/script&gt; 2.将下面这段代码放入页面内需要展示一句话的位置即可1&lt;div id="hitokoto"&gt;&lt;script&gt;hitokoto()&lt;/script&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个粗糙简单的导航页面]]></title>
    <url>%2F2017%2F07%2F12%2FAn-simple-personal-index-page%2F</url>
    <content type="text"><![CDATA[对于一个不太熟悉HTML/CSS/JS的小白来说，弄出一个导航页的东西还是费了不少功夫。下午弄了一个coding pages，把导航页所有相关的东西全部放上面，把主域名siphils.com绑了上去，以后访问这个博客就要用blog.siphils.com啦没有响应式没有响应式没有响应式！（明天看看怎么搞出来）⊙﹏⊙ 估计改成响应式的时候要把垃圾代码全部改掉，布局也不太好。暂时就这样吧。。。]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
</search>